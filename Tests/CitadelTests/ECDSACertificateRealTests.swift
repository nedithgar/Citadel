import XCTest
import Crypto
import _CryptoExtras
import NIO
@testable import Citadel
import NIOSSH

/// Tests for ECDSA certificates using real certificates generated by ssh-keygen
final class ECDSACertificateRealTests: XCTestCase {
    
    override class func setUp() {
        super.setUp()
        // Generate certificates dynamically for tests
        do {
            try SSHCertificateGenerator.ensureSSHKeygenAvailable()
            try SSHCertificateGenerator.setUp()
        } catch {
            XCTFail("Certificate generation setup failed: \(error)")
        }
    }
    
    override class func tearDown() {
        super.tearDown()
        // Clean up generated certificates
        do {
            try TestCertificateHelper.cleanUp()
        } catch {
            XCTFail("Certificate cleanup failed: \(error)")
        }
    }
    
    // MARK: - Helper Methods
    
    /// Check if certificate setup was successful, fail test if not
    private func requireCertificateSetup() {
        guard SSHCertificateGenerator.isSetupSuccessful else {
            XCTFail("Certificate generation setup failed - ssh-keygen may not be available")
        }
    }
    
    // MARK: - P256 Certificate Tests
    
    func testP256CertificateParsingWithRealCertificate() throws {
        requireCertificateSetup()
        let (privateKey, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        // Verify parsed data
        XCTAssertEqual(certificate.serial, 2)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.keyID, "test-user-p256")
        XCTAssertEqual(certificate.validPrincipals, ["testuser"])
        // Note: Time validation would need current time check
        
        // Test certificate can be converted to NIOSSHPublicKey
        let publicKey = NIOSSHPublicKey(certificate)
        XCTAssertNotNil(publicKey)
    }
    
    func testP256CertificateValidation() throws {
        requireCertificateSetup()
        // Principal validation with fresh certificates
        let (_, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test valid principal
        XCTAssertNoThrow(try certificate.validate(
            principal: "testuser",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // Test invalid principal
        XCTAssertThrowsError(try certificate.validate(
            principal: "wronguser",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        )) { error in
            XCTAssertTrue(error is NIOSSHError)
        }
    }
    
    // MARK: - P384 Certificate Tests
    
    func testP384CertificateParsingWithRealCertificate() throws {
        requireCertificateSetup()
        let (privateKey, certificate) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        // Verify parsed data
        XCTAssertEqual(certificate.serial, 3)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.keyID, "test-user-p384")
        XCTAssertEqual(certificate.validPrincipals, ["testuser", "admin"])
        // Note: Time validation would need current time check
        
        // Test certificate can be converted to NIOSSHPublicKey
        let publicKey = NIOSSHPublicKey(certificate)
        XCTAssertNotNil(publicKey)
    }
    
    func testP384CertificateMultiplePrincipals() throws {
        requireCertificateSetup()
        let (_, certificate) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test both valid principals
        XCTAssertNoThrow(try certificate.validate(
            principal: "testuser",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        XCTAssertNoThrow(try certificate.validate(
            principal: "admin",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // Test invalid principal
        XCTAssertThrowsError(try certificate.validate(
            principal: "nobody",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
    }
    
    // MARK: - P521 Certificate Tests
    
    func testP521CertificateParsingWithRealCertificate() throws {
        requireCertificateSetup()
        let (privateKey, certificate) = try TestCertificateHelper.parseP521Certificate(
            certificateFile: "user_ecdsa_p521-cert.pub",
            privateKeyFile: "user_ecdsa_p521"
        )
        
        // Verify parsed data
        XCTAssertEqual(certificate.serial, 4)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.keyID, "test-user-p521")
        XCTAssertEqual(certificate.validPrincipals, ["testuser"])
        // Note: Time validation would need current time check
        
        // Test certificate can be converted to NIOSSHPublicKey
        let publicKey = NIOSSHPublicKey(certificate)
        XCTAssertNotNil(publicKey)
    }
    
    // MARK: - Certificate Equality Tests
    
    func testCertificateEqualityWithRealCertificates() throws {
        requireCertificateSetup()
        // Generate two P256 certificates with the same configuration
        let (_, cert1) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        let (_, cert2) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        // Compare certificate properties (not the entire certificate since nonce/signature will differ)
        XCTAssertEqual(cert1.keyID, cert2.keyID)
        XCTAssertEqual(cert1.serial, cert2.serial)
        XCTAssertEqual(cert1.type, cert2.type)
        XCTAssertEqual(cert1.validPrincipals, cert2.validPrincipals)
        
        // Load a different certificate type
        let (_, cert3) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        // They should have different properties
        XCTAssertNotEqual(cert1.keyID, cert3.keyID)
        XCTAssertNotEqual(cert1.serial, cert3.serial)
    }
    
    // MARK: - Invalid Certificate Tests
    
    func testInvalidCertificateData() throws {
        requireCertificateSetup()
        // Test with completely invalid data
        let invalidData = Data("This is not a certificate".utf8)
        XCTAssertThrowsError(try NIOSSHCertificateLoader.loadFromBinaryData(invalidData)) { error in
            XCTAssertTrue(error is NIOSSHCertificateLoadingError)
        }
        
        // Test with wrong key type prefix
        var buffer = ByteBufferAllocator().buffer(capacity: 256)
        buffer.writeSSHString("ssh-rsa") // Not a certificate type
        let wrongTypeData = Data(buffer.readableBytesView)
        
        XCTAssertThrowsError(try NIOSSHCertificateLoader.loadFromBinaryData(wrongTypeData)) { error in
            XCTAssertTrue(error is NIOSSHCertificateLoadingError)
        }
    }
    
    func testCertificateTimeValidation() throws {
        requireCertificateSetup()
        // Generate a certificate with known validity period
        let (_, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        // Certificate should be valid now (generated with 2 hour validity)
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        XCTAssertNoThrow(try certificate.validate(
            principal: "testuser",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // Test with our enhanced validation that checks time
        XCTAssertNoThrow(try certificate.validateForAuthentication(
            username: "testuser",
            currentTime: Date()
        ))
    }
    
    // MARK: - Key Size Tests
    
    func testAllCurveSizes() throws {
        requireCertificateSetup()
        // Test that the public key sizes are correct for each curve
        let (_, p256Cert) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        let (_, p384Cert) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        let (_, p521Cert) = try TestCertificateHelper.parseP521Certificate(
            certificateFile: "user_ecdsa_p521-cert.pub",
            privateKeyFile: "user_ecdsa_p521"
        )
        
        // Verify certificates were loaded successfully
        XCTAssertNotNil(p256Cert)
        XCTAssertNotNil(p384Cert)
        XCTAssertNotNil(p521Cert)
    }
}