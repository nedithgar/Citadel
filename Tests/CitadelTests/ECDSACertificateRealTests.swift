import XCTest
import Crypto
import _CryptoExtras
import NIO
@testable import Citadel
import NIOSSH

/// Tests for ECDSA certificates using real certificates generated by ssh-keygen
final class ECDSACertificateRealTests: XCTestCase {
    
    // MARK: - P256 Certificate Tests
    
    func testP256CertificateParsingWithRealCertificate() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        // Verify parsed data
        XCTAssertEqual(certificate.certificate.serial, 2)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p256")
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser"])
        XCTAssertTrue(certificate.certificate.isValidNow)
        
        // Verify public key matches
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        
        // Test certificate serialization
        var buffer = ByteBufferAllocator().buffer(capacity: 2048)
        let written = certificate.write(to: &buffer)
        XCTAssertGreaterThan(written, 0)
        
        // Verify key type is written correctly
        buffer.moveReaderIndex(to: 0)
        let keyType = buffer.readSSHString()
        XCTAssertEqual(keyType, "ecdsa-sha2-nistp256-cert-v01@openssh.com")
    }
    
    func testP256CertificateValidation() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        // Test valid authentication
        XCTAssertNoThrow(
            try SSHAuthenticationMethod.p256Certificate(
                username: "testuser",
                privateKey: privateKey,
                certificate: certificate
            )
        )
        
        // Test invalid username with validation enabled
        XCTAssertThrowsError(
            try SSHAuthenticationMethod.p256Certificate(
                username: "wronguser",
                privateKey: privateKey,
                certificate: certificate,
                validateCertificate: true
            )
        ) { error in
            guard case SSHCertificateError.principalMismatch = error else {
                XCTFail("Expected principalMismatch error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - P384 Certificate Tests
    
    func testP384CertificateParsingWithRealCertificate() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        // Verify parsed data
        XCTAssertEqual(certificate.certificate.serial, 3)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p384")
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser", "admin"])
        XCTAssertTrue(certificate.certificate.isValidNow)
        
        // Verify public key matches
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        
        // Test serialization
        var buffer = ByteBufferAllocator().buffer(capacity: 2048)
        let written = certificate.write(to: &buffer)
        XCTAssertGreaterThan(written, 0)
        
        buffer.moveReaderIndex(to: 0)
        let keyType = buffer.readSSHString()
        XCTAssertEqual(keyType, "ecdsa-sha2-nistp384-cert-v01@openssh.com")
    }
    
    func testP384CertificateMultiplePrincipals() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        // Test both valid principals
        XCTAssertNoThrow(
            try SSHAuthenticationMethod.p384Certificate(
                username: "testuser",
                privateKey: privateKey,
                certificate: certificate
            )
        )
        
        XCTAssertNoThrow(
            try SSHAuthenticationMethod.p384Certificate(
                username: "admin",
                privateKey: privateKey,
                certificate: certificate
            )
        )
        
        // Test invalid principal with validation enabled
        XCTAssertThrowsError(
            try SSHAuthenticationMethod.p384Certificate(
                username: "guest",
                privateKey: privateKey,
                certificate: certificate,
                validateCertificate: true
            )
        ) { error in
            guard case SSHCertificateError.principalMismatch = error else {
                XCTFail("Expected principalMismatch error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - P521 Certificate Tests
    
    func testP521CertificateParsingWithRealCertificate() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP521Certificate(
            certificateFile: "user_ecdsa_p521-cert.pub",
            privateKeyFile: "user_ecdsa_p521"
        )
        
        // Verify parsed data
        XCTAssertEqual(certificate.certificate.serial, 4)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p521")
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser"])
        XCTAssertTrue(certificate.certificate.isValidNow)
        
        // Verify public key matches
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        
        // Test serialization
        var buffer = ByteBufferAllocator().buffer(capacity: 2048)
        let written = certificate.write(to: &buffer)
        XCTAssertGreaterThan(written, 0)
        
        buffer.moveReaderIndex(to: 0)
        let keyType = buffer.readSSHString()
        XCTAssertEqual(keyType, "ecdsa-sha2-nistp521-cert-v01@openssh.com")
    }
    
    // MARK: - Certificate Equality Tests
    
    func testCertificateEqualityWithRealCertificates() throws {
        // Load the same certificate twice
        let (_, cert1) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        let (_, cert2) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        // They should be equal (same serial and public key)
        XCTAssertTrue(cert1 == cert2)
        
        // Load a different certificate
        let (_, cert3) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        // Convert to P256 certificate for comparison (this will have different data)
        let differentCert = P256.Signing.CertificatePublicKey(
            certificate: cert3.certificate,
            publicKey: P256.Signing.PrivateKey().publicKey
        )
        
        // They should not be equal (different serial/key)
        XCTAssertFalse(cert1 == differentCert)
    }
    
    // MARK: - Invalid Certificate Tests
    
    func testInvalidCertificateData() throws {
        // Test with completely invalid data
        let invalidData = Data("This is not a certificate".utf8)
        XCTAssertThrowsError(try P256.Signing.CertificatePublicKey(certificateData: invalidData)) { error in
            XCTAssertTrue(error is SSHCertificateError)
        }
        
        // Test with wrong key type prefix
        var buffer = ByteBufferAllocator().buffer(capacity: 256)
        buffer.writeSSHString("ssh-rsa") // Wrong key type for P256
        let wrongTypeData = Data(buffer.readableBytesView)
        
        XCTAssertThrowsError(try P256.Signing.CertificatePublicKey(certificateData: wrongTypeData)) { error in
            XCTAssertTrue(error is SSHCertificateError)
        }
    }
    
    func testCertificateTimeValidation() throws {
        // Test with expired certificate
        let expiredCertData = try TestCertificateHelper.loadCertificate(filename: "user_expired-cert.pub")
        let expiredCert = try SSHCertificate(from: expiredCertData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertFalse(expiredCert.isValidNow)
        
        // Test with not yet valid certificate
        let futureCertData = try TestCertificateHelper.loadCertificate(filename: "user_not_yet_valid-cert.pub")
        let futureCert = try SSHCertificate(from: futureCertData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertFalse(futureCert.isValidNow)
    }
    
    // MARK: - Key Size Tests
    
    func testAllCurveSizes() throws {
        // Test that the public key sizes are correct for each curve
        let (_, p256Cert) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        let (_, p384Cert) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        let (_, p521Cert) = try TestCertificateHelper.parseP521Certificate(
            certificateFile: "user_ecdsa_p521-cert.pub",
            privateKeyFile: "user_ecdsa_p521"
        )
        
        // x963 representation includes the 0x04 prefix byte
        XCTAssertEqual(p256Cert.publicKey.x963Representation.count, 65) // 1 + 2*32
        XCTAssertEqual(p384Cert.publicKey.x963Representation.count, 97) // 1 + 2*48
        XCTAssertEqual(p521Cert.publicKey.x963Representation.count, 133) // 1 + 2*66
    }
}