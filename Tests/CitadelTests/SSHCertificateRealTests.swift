import XCTest
import NIOCore
import Crypto
@testable import Citadel

/// Tests using real SSH certificates generated by ssh-keygen
final class SSHCertificateRealTests: XCTestCase {
    
    override class func setUp() {
        super.setUp()
        // Ensure test certificates are generated
        let certDir = TestCertificateHelper.certificatesPath
        let fileManager = FileManager.default
        
        // Check if certificates exist, if not, generate them
        if !fileManager.fileExists(atPath: "\(certDir)/user_ed25519-cert.pub") {
            print("Test certificates not found. Please run generate_test_certificates.sh in the TestCertificates directory")
        }
    }
    
    // MARK: - Basic Certificate Parsing Tests
    
    func testEd25519CertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseEd25519Certificate(
            certificateFile: "user_ed25519-cert.pub",
            privateKeyFile: "user_ed25519"
        )
        
        // Verify certificate properties
        XCTAssertEqual(certificate.certificate.keyId, "test-user-ed25519")
        XCTAssertEqual(certificate.certificate.serial, 1)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser", "alice"])
        
        // Verify the public key matches
        XCTAssertEqual(certificate.publicKey.rawRepresentation, privateKey.publicKey.rawRepresentation)
        
        // Certificate should be valid now (generated with +1h validity)
        XCTAssertTrue(certificate.certificate.isValidNow)
    }
    
    func testP256CertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p256")
        XCTAssertEqual(certificate.certificate.serial, 2)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser"])
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        XCTAssertTrue(certificate.certificate.isValidNow)
    }
    
    func testP384CertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p384")
        XCTAssertEqual(certificate.certificate.serial, 3)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser", "admin"])
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        XCTAssertTrue(certificate.certificate.isValidNow)
    }
    
    func testP521CertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP521Certificate(
            certificateFile: "user_ecdsa_p521-cert.pub",
            privateKeyFile: "user_ecdsa_p521"
        )
        
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p521")
        XCTAssertEqual(certificate.certificate.serial, 4)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser"])
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        XCTAssertTrue(certificate.certificate.isValidNow)
    }
    
    func testRSACertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseRSACertificate(
            certificateFile: "user_rsa-cert.pub",
            privateKeyFile: "user_rsa"
        )
        
        XCTAssertEqual(certificate.certificate.keyId, "test-user-rsa")
        XCTAssertEqual(certificate.certificate.serial, 5)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser"])
        XCTAssertTrue(certificate.certificate.isValidNow)
        
        // Verify public key matches
        let pubKey = privateKey.publicKey as! Insecure.RSA.PublicKey
        XCTAssertEqual(certificate.publicKey.rawRepresentation, pubKey.rawRepresentation)
    }
    
    // MARK: - Host Certificate Tests
    
    func testHostCertificateParsing() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "host_ed25519-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "test-host")
        XCTAssertEqual(certificate.serial, 100)
        XCTAssertEqual(certificate.type, .host)
        XCTAssertEqual(certificate.validPrincipals, ["*.example.com", "example.com"])
        XCTAssertTrue(certificate.isValidNow)
        
        // Test hostname validation
        let context1 = SSHCertificateValidationContext(hostname: "example.com")
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: context1))
        
        let context2 = SSHCertificateValidationContext(hostname: "test.example.com")
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: context2))
    }
    
    // MARK: - Time Validation Tests
    
    func testExpiredCertificate() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_expired-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "expired-cert")
        XCTAssertEqual(certificate.serial, 200)
        XCTAssertFalse(certificate.isValidNow)
        
        let context = SSHCertificateValidationContext(username: "testuser")
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: context)) { error in
            guard case SSHCertificateValidationError.expired = error else {
                XCTFail("Expected expired error, got \(error)")
                return
            }
        }
    }
    
    func testNotYetValidCertificate() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_not_yet_valid-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "future-cert")
        XCTAssertEqual(certificate.serial, 201)
        XCTAssertFalse(certificate.isValidNow)
        
        let context = SSHCertificateValidationContext(username: "testuser")
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: context)) { error in
            guard case SSHCertificateValidationError.notYetValid = error else {
                XCTFail("Expected notYetValid error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - Critical Options Tests
    
    func testCriticalOptions() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_critical_options-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "restricted-cert")
        XCTAssertEqual(certificate.serial, 202)
        
        // Check critical options
        XCTAssertEqual(certificate.forceCommand, "/bin/date")
        XCTAssertEqual(certificate.sourceAddress, "192.168.1.0/24,10.0.0.1")
        
        // Test source address validation
        let validContext = SSHCertificateValidationContext(
            username: "testuser",
            sourceAddress: "192.168.1.100"
        )
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: validContext))
        
        let invalidContext = SSHCertificateValidationContext(
            username: "testuser",
            sourceAddress: "172.16.0.1"
        )
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: invalidContext)) { error in
            guard case SSHCertificateValidationError.invalidSourceAddress = error else {
                XCTFail("Expected invalidSourceAddress error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - Principal Validation Tests
    
    func testLimitedPrincipals() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_limited_principals-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "limited-cert")
        XCTAssertEqual(certificate.serial, 203)
        XCTAssertEqual(certificate.validPrincipals, ["alice", "bob"])
        
        // Test valid principals
        let aliceContext = SSHCertificateValidationContext(username: "alice")
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: aliceContext))
        
        let bobContext = SSHCertificateValidationContext(username: "bob")
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: bobContext))
        
        // Test invalid principal
        let charlieContext = SSHCertificateValidationContext(username: "charlie")
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: charlieContext)) { error in
            guard case SSHCertificateValidationError.invalidPrincipal("charlie") = error else {
                XCTFail("Expected invalidPrincipal error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - Extensions Tests
    
    func testAllExtensions() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_all_extensions-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "full-cert")
        XCTAssertEqual(certificate.serial, 204)
        
        // Verify all extensions are present
        XCTAssertTrue(certificate.permitX11Forwarding)
        XCTAssertTrue(certificate.permitAgentForwarding)
        XCTAssertTrue(certificate.permitPortForwarding)
        XCTAssertTrue(certificate.permitPty)
        XCTAssertTrue(certificate.permitUserRc)
    }
    
    // MARK: - Authentication Method Tests
    
    func testCertificateAuthenticationMethods() throws {
        // Test Ed25519 certificate authentication
        let (ed25519PrivateKey, ed25519Cert) = try TestCertificateHelper.parseEd25519Certificate(
            certificateFile: "user_ed25519-cert.pub",
            privateKeyFile: "user_ed25519"
        )
        
        XCTAssertNoThrow(
            try SSHAuthenticationMethod.ed25519Certificate(
                username: "testuser",
                privateKey: ed25519PrivateKey,
                certificate: ed25519Cert
            )
        )
        
        // Test with wrong username (not in principals)
        XCTAssertThrowsError(
            try SSHAuthenticationMethod.ed25519Certificate(
                username: "wronguser",
                privateKey: ed25519PrivateKey,
                certificate: ed25519Cert
            )
        ) { error in
            guard case SSHCertificateValidationError.invalidPrincipal = error else {
                XCTFail("Expected invalidPrincipal error, got \(error)")
                return
            }
        }
    }
}