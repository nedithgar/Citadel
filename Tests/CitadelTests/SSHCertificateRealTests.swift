import XCTest
import NIOCore
import Crypto
@testable import Citadel

/// Tests using real SSH certificates generated by ssh-keygen
final class SSHCertificateRealTests: XCTestCase {
    
    override class func setUp() {
        super.setUp()
        // Generate certificates dynamically for tests
        do {
            try SSHCertificateGenerator.ensureSSHKeygenAvailable()
            try SSHCertificateGenerator.setUp()
        } catch {
            print("Failed to set up certificate generation: \(error)")
        }
    }
    
    override class func tearDown() {
        super.tearDown()
        // Clean up generated certificates
        do {
            try TestCertificateHelper.cleanUp()
        } catch {
            print("Failed to clean up certificates: \(error)")
        }
    }
    
    // MARK: - Basic Certificate Parsing Tests
    
    func testEd25519CertificateParsing() throws {
        let (_, certificate) = try TestCertificateHelper.parseEd25519Certificate(
            certificateFile: "user_ed25519-cert.pub",
            privateKeyFile: "user_ed25519"
        )
        
        // Verify certificate properties
        XCTAssertEqual(certificate.keyID, "test-user-ed25519")
        XCTAssertEqual(certificate.serial, 1)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser", "alice"])
        
        // Certificate was loaded successfully
        XCTAssertNotNil(certificate)
    }
    
    func testP256CertificateParsing() throws {
        let (_, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        XCTAssertEqual(certificate.keyID, "test-user-p256")
        XCTAssertEqual(certificate.serial, 2)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser"])
        
        // Certificate was loaded successfully
        XCTAssertNotNil(certificate)
    }
    
    func testP384CertificateParsing() throws {
        let (_, certificate) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        XCTAssertEqual(certificate.keyID, "test-user-p384")
        XCTAssertEqual(certificate.serial, 3)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser", "admin"])
        
        // Certificate was loaded successfully
        XCTAssertNotNil(certificate)
    }
    
    func testP521CertificateParsing() throws {
        let (_, certificate) = try TestCertificateHelper.parseP521Certificate(
            certificateFile: "user_ecdsa_p521-cert.pub",
            privateKeyFile: "user_ecdsa_p521"
        )
        
        XCTAssertEqual(certificate.keyID, "test-user-p521")
        XCTAssertEqual(certificate.serial, 4)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser"])
        
        // Certificate was loaded successfully
        XCTAssertNotNil(certificate)
    }
    
    func testRSACertificateParsing() throws {
        // SKIP TEST: RSA certificates are not supported by NIOSSH
        throw XCTSkip("RSA certificates are not supported by NIOSSH")
        let (_, certificate) = try TestCertificateHelper.parseRSACertificate(
            certificateFile: "user_rsa-cert.pub",
            privateKeyFile: "user_rsa"
        )
        
        XCTAssertEqual(certificate.keyID, "test-user-rsa")
        XCTAssertEqual(certificate.serial, 5)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser"])
    }
    
    // MARK: - Host Certificate Tests
    
    func testHostCertificateParsing() throws {
        let certificate = try TestCertificateHelper.generateHostCertificate()
        
        XCTAssertEqual(certificate.keyID, "test-host")
        XCTAssertEqual(certificate.serial, 100)
        XCTAssertEqual(certificate.type, .host)
        XCTAssertEqual(certificate.validPrincipals, ["*.example.com", "example.com"])
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // First validate the certificate signature with NIOSSH
        XCTAssertNoThrow(try certificate.validate(
            principal: "example.com",
            type: .host,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // Now test wildcard matching with our enhanced validation
        XCTAssertNoThrow(try certificate.validateForAuthentication(
            hostname: "test.example.com"
        )) // Should work with wildcard
    }
    
    // MARK: - Time Validation Tests
    
    func testExpiredCertificate() throws {
        // Skip test - expired certificate handling requires certificates with known validity periods
        throw XCTSkip("Expired certificate tests require certificates with specific validity periods")
    }
    
    func testNotYetValidCertificate() throws {
        // Skip test - future certificate handling requires certificates with known validity periods
        throw XCTSkip("Future certificate tests require certificates with specific validity periods")
    }
    
    // MARK: - Critical Options Tests
    
    func testCriticalOptions() throws {
        let certificate = try TestCertificateHelper.generateCriticalOptionsCertificate()
        
        XCTAssertEqual(certificate.keyID, "restricted-cert")
        XCTAssertEqual(certificate.serial, 202)
        
        // Check critical options
        XCTAssertEqual(certificate.criticalOptions["force-command"], "/bin/date")
        XCTAssertEqual(certificate.criticalOptions["source-address"], "192.168.1.0/24,10.0.0.1")
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test basic validation
        XCTAssertNoThrow(try certificate.validate(
            principal: "testuser",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey],
            acceptableCriticalOptions: ["force-command", "source-address"]
        ))
    }
    
    // MARK: - Principal Validation Tests
    
    func testLimitedPrincipals() throws {
        let certificate = try TestCertificateHelper.generateLimitedPrincipalsCertificate()
        
        XCTAssertEqual(certificate.keyID, "limited-cert")
        XCTAssertEqual(certificate.serial, 203)
        XCTAssertEqual(certificate.validPrincipals, ["alice", "bob"])
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test valid principals
        XCTAssertNoThrow(try certificate.validate(
            principal: "alice",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        XCTAssertNoThrow(try certificate.validate(
            principal: "bob",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // Test invalid principal
        XCTAssertThrowsError(try certificate.validate(
            principal: "charlie",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
    }
    
    // MARK: - Extensions Tests
    
    func testAllExtensions() throws {
        let certificate = try TestCertificateHelper.generateAllExtensionsCertificate()
        
        XCTAssertEqual(certificate.keyID, "full-cert")
        XCTAssertEqual(certificate.serial, 204)
        
        // Verify all extensions are present
        XCTAssertTrue(certificate.permitX11Forwarding)
        XCTAssertTrue(certificate.permitAgentForwarding)
        XCTAssertTrue(certificate.permitPortForwarding)
        XCTAssertTrue(certificate.permitPty)
        XCTAssertTrue(certificate.permitUserRc)
    }
    
    // MARK: - Authentication Method Tests
    
    func testCertificateAuthenticationMethods() throws {
        // Test certificate authentication with fresh certificates
        let (privateKey, certificate) = try TestCertificateHelper.parseEd25519Certificate(
            certificateFile: "user_ed25519-cert.pub",
            privateKeyFile: "user_ed25519"
        )
        
        // Verify the certificate is valid
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        XCTAssertNoThrow(try certificate.validate(
            principal: "testuser",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // The authentication method can be created with certificate
        let authMethod = try SSHAuthenticationMethod.ed25519Certificate(
            username: "testuser",
            privateKey: privateKey,
            certificate: certificate
        )
        
        // Verify the auth method was created successfully
        XCTAssertNotNil(authMethod)
    }
    
    // MARK: - Signature Type Tests
    
    func testSignatureTypeExtraction() throws {
        // Skip - signature type extraction is internal to NIOSSH
        throw XCTSkip("Signature type extraction is internal to NIOSSH")
    }
    
    func testSignatureTypeValidation() throws {
        // Skip - signature algorithm validation is handled internally by NIOSSH
        throw XCTSkip("Signature algorithm validation is handled internally by NIOSSH")
    }
    
    func testSignatureTypeInValidateForAuthentication() throws {
        // Skip - signature algorithm validation is handled internally by NIOSSH
        throw XCTSkip("Signature algorithm validation is handled internally by NIOSSH")
    }
}