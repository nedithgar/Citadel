import XCTest
import NIOCore
import Crypto
@testable import Citadel

/// Tests using real SSH certificates generated by ssh-keygen
final class SSHCertificateRealTests: XCTestCase {
    
    override class func setUp() {
        super.setUp()
        // Ensure test certificates are generated
        let certDir = TestCertificateHelper.certificatesPath
        let fileManager = FileManager.default
        
        // Check if certificates exist, if not, generate them
        if !fileManager.fileExists(atPath: "\(certDir)/user_ed25519-cert.pub") {
            print("Test certificates not found. Please run generate_test_certificates.sh in the TestCertificates directory")
        }
    }
    
    // MARK: - Basic Certificate Parsing Tests
    
    func testEd25519CertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseEd25519Certificate(
            certificateFile: "user_ed25519-cert.pub",
            privateKeyFile: "user_ed25519"
        )
        
        // Verify certificate properties
        XCTAssertEqual(certificate.certificate.keyId, "test-user-ed25519")
        XCTAssertEqual(certificate.certificate.serial, 1)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser", "alice"])
        
        // Verify the public key matches
        XCTAssertEqual(certificate.publicKey.rawRepresentation, privateKey.publicKey.rawRepresentation)
        
        // Note: Certificate was generated with +1h validity, but may have expired
        // Check if certificate is expired to provide better error message
        if !certificate.certificate.isValidNow {
            print("Certificate may have expired. Run generate_test_certificates.sh to regenerate.")
        }
    }
    
    func testP256CertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p256")
        XCTAssertEqual(certificate.certificate.serial, 2)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser"])
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        
        if !certificate.certificate.isValidNow {
            print("Certificate may have expired. Run generate_test_certificates.sh to regenerate.")
        }
    }
    
    func testP384CertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p384")
        XCTAssertEqual(certificate.certificate.serial, 3)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser", "admin"])
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        
        if !certificate.certificate.isValidNow {
            print("Certificate may have expired. Run generate_test_certificates.sh to regenerate.")
        }
    }
    
    func testP521CertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseP521Certificate(
            certificateFile: "user_ecdsa_p521-cert.pub",
            privateKeyFile: "user_ecdsa_p521"
        )
        
        XCTAssertEqual(certificate.certificate.keyId, "test-user-p521")
        XCTAssertEqual(certificate.certificate.serial, 4)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser"])
        XCTAssertEqual(certificate.publicKey.x963Representation, privateKey.publicKey.x963Representation)
        
        if !certificate.certificate.isValidNow {
            print("Certificate may have expired. Run generate_test_certificates.sh to regenerate.")
        }
    }
    
    func testRSACertificateParsing() throws {
        let (privateKey, certificate) = try TestCertificateHelper.parseRSACertificate(
            certificateFile: "user_rsa-cert.pub",
            privateKeyFile: "user_rsa"
        )
        
        XCTAssertEqual(certificate.certificate.keyId, "test-user-rsa")
        XCTAssertEqual(certificate.certificate.serial, 5)
        XCTAssertEqual(certificate.certificate.type, .user)
        XCTAssertEqual(certificate.certificate.validPrincipals, ["testuser"])
        
        if !certificate.certificate.isValidNow {
            print("Certificate may have expired. Run generate_test_certificates.sh to regenerate.")
        }
        
        // Verify public key matches
        let pubKey = privateKey.publicKey as! Insecure.RSA.PublicKey
        XCTAssertEqual(certificate.publicKey.rawRepresentation, pubKey.rawRepresentation)
    }
    
    // MARK: - Host Certificate Tests
    
    func testHostCertificateParsing() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "host_ed25519-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "test-host")
        XCTAssertEqual(certificate.serial, 100)
        XCTAssertEqual(certificate.type, .host)
        XCTAssertEqual(certificate.validPrincipals, ["*.example.com", "example.com"])
        
        if !certificate.isValidNow {
            print("Certificate may have expired. Run generate_test_certificates.sh to regenerate.")
        }
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test hostname validation
        let context1 = SSHCertificateValidationContext(hostname: "example.com", trustedCAs: [caPublicKey])
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: context1))
        
        let context2 = SSHCertificateValidationContext(hostname: "test.example.com", trustedCAs: [caPublicKey])
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: context2)) // Should work with wildcard
    }
    
    // MARK: - Time Validation Tests
    
    func testExpiredCertificate() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_expired-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "expired-cert")
        XCTAssertEqual(certificate.serial, 200)
        XCTAssertFalse(certificate.isValidNow)
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        let context = SSHCertificateValidationContext(username: "testuser", trustedCAs: [caPublicKey])
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: context)) { error in
            guard case SSHCertificateError.expired = error else {
                XCTFail("Expected expired error, got \(error)")
                return
            }
        }
    }
    
    func testNotYetValidCertificate() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_not_yet_valid-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "future-cert")
        XCTAssertEqual(certificate.serial, 201)
        XCTAssertFalse(certificate.isValidNow)
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        let context = SSHCertificateValidationContext(username: "testuser", trustedCAs: [caPublicKey])
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: context)) { error in
            guard case SSHCertificateError.notYetValid = error else {
                XCTFail("Expected notYetValid error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - Critical Options Tests
    
    func testCriticalOptions() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_critical_options-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "restricted-cert")
        XCTAssertEqual(certificate.serial, 202)
        
        // Check critical options
        XCTAssertEqual(certificate.forceCommand, "/bin/date")
        XCTAssertEqual(certificate.sourceAddress, "192.168.1.0/24,10.0.0.1")
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test source address validation
        let validContext = SSHCertificateValidationContext(
            username: "testuser",
            sourceAddress: "192.168.1.100",
            trustedCAs: [caPublicKey]
        )
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: validContext))
        
        let invalidContext = SSHCertificateValidationContext(
            username: "testuser",
            sourceAddress: "172.16.0.1",
            trustedCAs: [caPublicKey]
        )
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: invalidContext)) { error in
            guard case SSHCertificateError.sourceAddressNotAllowed = error else {
                XCTFail("Expected sourceAddressNotAllowed error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - Principal Validation Tests
    
    func testLimitedPrincipals() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_limited_principals-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "limited-cert")
        XCTAssertEqual(certificate.serial, 203)
        XCTAssertEqual(certificate.validPrincipals, ["alice", "bob"])
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test valid principals
        let aliceContext = SSHCertificateValidationContext(username: "alice", trustedCAs: [caPublicKey])
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: aliceContext))
        
        let bobContext = SSHCertificateValidationContext(username: "bob", trustedCAs: [caPublicKey])
        XCTAssertNoThrow(try SSHCertificateValidator.validate(certificate, context: bobContext))
        
        // Test invalid principal
        let charlieContext = SSHCertificateValidationContext(username: "charlie", trustedCAs: [caPublicKey])
        XCTAssertThrowsError(try SSHCertificateValidator.validate(certificate, context: charlieContext)) { error in
            guard case SSHCertificateError.principalMismatch = error else {
                XCTFail("Expected principalMismatch error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - Extensions Tests
    
    func testAllExtensions() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_all_extensions-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        XCTAssertEqual(certificate.keyId, "full-cert")
        XCTAssertEqual(certificate.serial, 204)
        
        // Verify all extensions are present
        XCTAssertTrue(certificate.permitX11Forwarding)
        XCTAssertTrue(certificate.permitAgentForwarding)
        XCTAssertTrue(certificate.permitPortForwarding)
        XCTAssertTrue(certificate.permitPty)
        XCTAssertTrue(certificate.permitUserRc)
    }
    
    // MARK: - Authentication Method Tests
    
    func testCertificateAuthenticationMethods() throws {
        // Test Ed25519 certificate authentication
        let (ed25519PrivateKey, ed25519Cert) = try TestCertificateHelper.parseEd25519Certificate(
            certificateFile: "user_ed25519-cert.pub",
            privateKeyFile: "user_ed25519"
        )
        
        // Creating certificate auth method should succeed for valid principal
        let authMethod = try SSHAuthenticationMethod.ed25519Certificate(
            username: "testuser",
            privateKey: ed25519PrivateKey,
            certificate: ed25519Cert
        )
        XCTAssertNotNil(authMethod)
        
        // Test with wrong username (not in principals) - should succeed without validation
        XCTAssertNoThrow(
            try SSHAuthenticationMethod.ed25519Certificate(
                username: "wronguser",
                privateKey: ed25519PrivateKey,
                certificate: ed25519Cert
            )
        )
        
        // Test with wrong username and validation enabled - should throw
        XCTAssertThrowsError(
            try SSHAuthenticationMethod.ed25519Certificate(
                username: "wronguser",
                privateKey: ed25519PrivateKey,
                certificate: ed25519Cert,
                validateCertificate: true
            )
        ) { error in
            guard case SSHCertificateError.principalMismatch = error else {
                XCTFail("Expected principalMismatch error, got \(error)")
                return
            }
        }
    }
    
    // MARK: - Signature Type Tests
    
    func testSignatureTypeExtraction() throws {
        // Test Ed25519 certificate - should have ssh-ed25519 signature type
        let ed25519CertData = try TestCertificateHelper.loadCertificate(filename: "user_ed25519-cert.pub")
        let ed25519Cert = try SSHCertificate(from: ed25519CertData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        XCTAssertEqual(ed25519Cert.signatureType, "ssh-ed25519")
        
        // Test P256 certificate - should have ecdsa-sha2-nistp256 signature type
        let p256CertData = try TestCertificateHelper.loadCertificate(filename: "user_ecdsa_p256-cert.pub")
        let p256Cert = try SSHCertificate(from: p256CertData, expectedKeyType: "ecdsa-sha2-nistp256-cert-v01@openssh.com")
        XCTAssertEqual(p256Cert.signatureType, "ecdsa-sha2-nistp256")
        
        // Test P384 certificate - should have ecdsa-sha2-nistp384 signature type
        let p384CertData = try TestCertificateHelper.loadCertificate(filename: "user_ecdsa_p384-cert.pub")
        let p384Cert = try SSHCertificate(from: p384CertData, expectedKeyType: "ecdsa-sha2-nistp384-cert-v01@openssh.com")
        XCTAssertEqual(p384Cert.signatureType, "ecdsa-sha2-nistp384")
        
        // Test P521 certificate - should have ecdsa-sha2-nistp521 signature type
        let p521CertData = try TestCertificateHelper.loadCertificate(filename: "user_ecdsa_p521-cert.pub")
        let p521Cert = try SSHCertificate(from: p521CertData, expectedKeyType: "ecdsa-sha2-nistp521-cert-v01@openssh.com")
        XCTAssertEqual(p521Cert.signatureType, "ecdsa-sha2-nistp521")
        
        // Test RSA certificate - could be ssh-rsa, rsa-sha2-256, or rsa-sha2-512
        let rsaCertData = try TestCertificateHelper.loadCertificate(filename: "user_rsa-cert.pub")
        let rsaCert = try SSHCertificate(from: rsaCertData, expectedKeyType: "ssh-rsa-cert-v01@openssh.com")
        XCTAssertNotNil(rsaCert.signatureType)
        XCTAssertTrue(["ssh-rsa", "rsa-sha2-256", "rsa-sha2-512"].contains(rsaCert.signatureType!))
    }
    
    func testSignatureTypeValidation() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_ed25519-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        
        // Test with allowed algorithms
        XCTAssertTrue(certificate.checkSignatureType(allowedAlgorithms: "ssh-ed25519,ssh-rsa"))
        XCTAssertTrue(certificate.checkSignatureType(allowedAlgorithms: "ssh-ed25519"))
        
        // Test with disallowed algorithms
        XCTAssertFalse(certificate.checkSignatureType(allowedAlgorithms: "ssh-rsa,rsa-sha2-256"))
        XCTAssertFalse(certificate.checkSignatureType(allowedAlgorithms: "ecdsa-sha2-nistp256"))
        
        // Test with nil/empty allowed algorithms (should accept any)
        XCTAssertTrue(certificate.checkSignatureType(allowedAlgorithms: nil))
        XCTAssertTrue(certificate.checkSignatureType(allowedAlgorithms: ""))
    }
    
    func testSignatureTypeInValidateForAuthentication() throws {
        let certData = try TestCertificateHelper.loadCertificate(filename: "user_ed25519-cert.pub")
        let certificate = try SSHCertificate(from: certData, expectedKeyType: "ssh-ed25519-cert-v01@openssh.com")
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test with allowed signature algorithm
        // Use a fixed time within the certificate validity period to avoid expiration
        let fixedTime = certificate.validAfter + 1800 // 30 minutes after valid_after
        XCTAssertNoThrow(
            try certificate.validateForAuthentication(
                username: "testuser",
                clientAddress: "127.0.0.1",
                trustedCAs: [caPublicKey],
                currentTime: fixedTime,
                allowedSignatureAlgorithms: "ssh-ed25519,ssh-rsa"
            )
        )
        
        // Test with disallowed signature algorithm
        XCTAssertThrowsError(
            try certificate.validateForAuthentication(
                username: "testuser",
                clientAddress: "127.0.0.1",
                trustedCAs: [caPublicKey],
                currentTime: fixedTime,
                allowedSignatureAlgorithms: "ssh-rsa,rsa-sha2-256"
            )
        ) { error in
            guard case SSHCertificateError.disallowedSignatureAlgorithm(let algorithm) = error else {
                XCTFail("Expected disallowedSignatureAlgorithm error, got \(error)")
                return
            }
            XCTAssertEqual(algorithm, "ssh-ed25519")
        }
    }
}