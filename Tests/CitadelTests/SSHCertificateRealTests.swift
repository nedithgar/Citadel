import XCTest
import NIOCore
import Crypto
@testable import Citadel

/// Tests using real SSH certificates generated by ssh-keygen
final class SSHCertificateRealTests: XCTestCase {
    
    override func setUp() {
        super.setUp()
        // Generate certificates dynamically for tests (only once)
        if !SSHCertificateGenerator.hasAttemptedSetup {
            SSHCertificateGenerator.hasAttemptedSetup = true
            do {
                try SSHCertificateGenerator.ensureSSHKeygenAvailable()
                try SSHCertificateGenerator.setUp()
                SSHCertificateGenerator.isSetupSuccessful = true
            } catch {
                SSHCertificateGenerator.setupError = error
                SSHCertificateGenerator.isSetupSuccessful = false
            }
        }
        
        // Check setup success for each test
        if !SSHCertificateGenerator.isSetupSuccessful {
            if let error = SSHCertificateGenerator.setupError {
                XCTFail("Certificate generation setup failed: \(error)")
            } else {
                XCTFail("Certificate generation setup failed")
            }
        }
    }
    
    override func tearDown() {
        super.tearDown()
        // Clean up generated certificates
        do {
            try TestCertificateHelper.cleanUp()
        } catch {
            XCTFail("Certificate cleanup failed: \(error)")
        }
    }
    
    // MARK: - Basic Certificate Parsing Tests
    
    func testEd25519CertificateParsing() throws {
                let (_, certificate) = try TestCertificateHelper.parseEd25519Certificate(
            certificateFile: "user_ed25519-cert.pub",
            privateKeyFile: "user_ed25519"
        )
        
        // Verify certificate properties
        XCTAssertEqual(certificate.keyID, "test-user-ed25519")
        XCTAssertEqual(certificate.serial, 1)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser", "alice"])
        
        // Certificate was loaded successfully
        XCTAssertNotNil(certificate)
    }
    
    func testP256CertificateParsing() throws {
                let (_, certificate) = try TestCertificateHelper.parseP256Certificate(
            certificateFile: "user_ecdsa_p256-cert.pub",
            privateKeyFile: "user_ecdsa_p256"
        )
        
        XCTAssertEqual(certificate.keyID, "test-user-p256")
        XCTAssertEqual(certificate.serial, 2)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser"])
        
        // Certificate was loaded successfully
        XCTAssertNotNil(certificate)
    }
    
    func testP384CertificateParsing() throws {
                let (_, certificate) = try TestCertificateHelper.parseP384Certificate(
            certificateFile: "user_ecdsa_p384-cert.pub",
            privateKeyFile: "user_ecdsa_p384"
        )
        
        XCTAssertEqual(certificate.keyID, "test-user-p384")
        XCTAssertEqual(certificate.serial, 3)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser", "admin"])
        
        // Certificate was loaded successfully
        XCTAssertNotNil(certificate)
    }
    
    func testP521CertificateParsing() throws {
                let (_, certificate) = try TestCertificateHelper.parseP521Certificate(
            certificateFile: "user_ecdsa_p521-cert.pub",
            privateKeyFile: "user_ecdsa_p521"
        )
        
        XCTAssertEqual(certificate.keyID, "test-user-p521")
        XCTAssertEqual(certificate.serial, 4)
        XCTAssertEqual(certificate.type, .user)
        XCTAssertEqual(certificate.validPrincipals, ["testuser"])
        
        // Certificate was loaded successfully
        XCTAssertNotNil(certificate)
    }
    
    
    // MARK: - Host Certificate Tests
    
    func testHostCertificateParsing() throws {
                let certificate = try TestCertificateHelper.generateHostCertificate()
        
        XCTAssertEqual(certificate.keyID, "test-host")
        XCTAssertEqual(certificate.serial, 100)
        XCTAssertEqual(certificate.type, .host)
        XCTAssertEqual(certificate.validPrincipals, ["*.example.com", "example.com"])
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // First validate the certificate signature with NIOSSH
        XCTAssertNoThrow(try certificate.validate(
            principal: "example.com",
            type: .host,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // Now test wildcard matching with our enhanced validation
        XCTAssertNoThrow(try certificate.validateForAuthentication(
            hostname: "test.example.com"
        )) // Should work with wildcard
    }
    
    // MARK: - Time Validation Tests
    
    
    // MARK: - Critical Options Tests
    
    func testCriticalOptions() throws {
                let certificate = try TestCertificateHelper.generateCriticalOptionsCertificate()
        
        XCTAssertEqual(certificate.keyID, "restricted-cert")
        XCTAssertEqual(certificate.serial, 202)
        
        // Check critical options
        XCTAssertEqual(certificate.criticalOptions["force-command"], "/bin/date")
        XCTAssertEqual(certificate.criticalOptions["source-address"], "192.168.1.0/24,10.0.0.1")
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test basic validation
        XCTAssertNoThrow(try certificate.validate(
            principal: "testuser",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey],
            acceptableCriticalOptions: ["force-command", "source-address"]
        ))
    }
    
    // MARK: - Principal Validation Tests
    
    func testLimitedPrincipals() throws {
                let certificate = try TestCertificateHelper.generateLimitedPrincipalsCertificate()
        
        XCTAssertEqual(certificate.keyID, "limited-cert")
        XCTAssertEqual(certificate.serial, 203)
        XCTAssertEqual(certificate.validPrincipals, ["alice", "bob"])
        
        // Load the CA public key for validation
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        
        // Test valid principals
        XCTAssertNoThrow(try certificate.validate(
            principal: "alice",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        XCTAssertNoThrow(try certificate.validate(
            principal: "bob",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // Test invalid principal
        XCTAssertThrowsError(try certificate.validate(
            principal: "charlie",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
    }
    
    // MARK: - Extensions Tests
    
    func testAllExtensions() throws {
                let certificate = try TestCertificateHelper.generateAllExtensionsCertificate()
        
        XCTAssertEqual(certificate.keyID, "full-cert")
        XCTAssertEqual(certificate.serial, 204)
        
        // Verify all extensions are present
        XCTAssertTrue(certificate.permitX11Forwarding)
        XCTAssertTrue(certificate.permitAgentForwarding)
        XCTAssertTrue(certificate.permitPortForwarding)
        XCTAssertTrue(certificate.permitPty)
        XCTAssertTrue(certificate.permitUserRc)
    }
    
    // MARK: - Authentication Method Tests
    
    func testCertificateAuthenticationMethods() throws {
                // Test certificate authentication with fresh certificates
        let (privateKey, certificate) = try TestCertificateHelper.parseEd25519Certificate(
            certificateFile: "user_ed25519-cert.pub",
            privateKeyFile: "user_ed25519"
        )
        
        // Verify the certificate is valid
        let caPublicKey = try TestCertificateHelper.loadPublicKey(name: "ca_ed25519")
        XCTAssertNoThrow(try certificate.validate(
            principal: "testuser",
            type: .user,
            allowedAuthoritySigningKeys: [caPublicKey]
        ))
        
        // The authentication method can be created with certificate
        let authMethod = try SSHAuthenticationMethod.ed25519Certificate(
            username: "testuser",
            privateKey: privateKey,
            certificate: certificate
        )
        
        // Verify the auth method was created successfully
        XCTAssertNotNil(authMethod)
    }
    
    // MARK: - Signature Type Tests
    
}