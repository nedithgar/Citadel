import Foundation
import Crypto
import _CryptoExtras
import NIOSSH
import NIOCore
import CCryptoBoringSSL
@testable import Citadel

/// Helper class to load and parse real SSH certificates generated by ssh-keygen
final class TestCertificateHelper {
    
    /// Base path to test certificates directory
    static var certificatesPath: String {
        let currentFile = #file
        let currentDirectory = (currentFile as NSString).deletingLastPathComponent
        return "\(currentDirectory)/TestCertificates"
    }
    
    /// Load a certificate file
    static func loadCertificate(filename: String) throws -> Data {
        let path = "\(certificatesPath)/\(filename)"
        guard let data = FileManager.default.contents(atPath: path) else {
            throw TestError.fileNotFound(path)
        }
        
        // SSH certificates are in OpenSSH format, need to parse the base64
        let contents = String(data: data, encoding: .utf8)!.trimmingCharacters(in: .whitespacesAndNewlines)
        let parts = contents.split(separator: " ")
        
        guard parts.count >= 2 else {
            throw TestError.invalidFormat
        }
        
        // The second part is the base64-encoded certificate
        guard let certData = Data(base64Encoded: String(parts[1])) else {
            throw TestError.invalidBase64
        }
        
        return certData
    }
    
    /// Load a private key file
    static func loadPrivateKey(filename: String) throws -> Data {
        let path = "\(certificatesPath)/\(filename)"
        guard let data = FileManager.default.contents(atPath: path) else {
            throw TestError.fileNotFound(path)
        }
        return data
    }
    
    /// Parse an Ed25519 certificate
    static func parseEd25519Certificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: Curve25519.Signing.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        let keyData = try loadPrivateKey(filename: privateKeyFile)
        
        // Parse the OpenSSH private key
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<Curve25519.Signing.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: "\(certificatesPath)/\(certificateFile)")
        
        return (privateKey, cert)
    }
    
    /// Parse a P256 ECDSA certificate
    static func parseP256Certificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: P256.Signing.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        let keyData = try loadPrivateKey(filename: privateKeyFile)
        
        // Parse the OpenSSH private key
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<P256.Signing.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: "\(certificatesPath)/\(certificateFile)")
        
        return (privateKey, cert)
    }
    
    /// Parse a P384 ECDSA certificate
    static func parseP384Certificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: P384.Signing.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        let keyData = try loadPrivateKey(filename: privateKeyFile)
        
        // Parse the OpenSSH private key
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<P384.Signing.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: "\(certificatesPath)/\(certificateFile)")
        
        return (privateKey, cert)
    }
    
    /// Parse a P521 ECDSA certificate
    static func parseP521Certificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: P521.Signing.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        let keyData = try loadPrivateKey(filename: privateKeyFile)
        
        // Parse the OpenSSH private key
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<P521.Signing.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: "\(certificatesPath)/\(certificateFile)")
        
        return (privateKey, cert)
    }
    
    /// Parse an RSA certificate
    static func parseRSACertificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: Insecure.RSA.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        let keyData = try loadPrivateKey(filename: privateKeyFile)
        
        // Parse the OpenSSH private key
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<Insecure.RSA.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: "\(certificatesPath)/\(certificateFile)")
        
        return (privateKey, cert)
    }
    
    /// Load certificate data directly (without the key type prefix)
    static func loadCertificateData(name: String) throws -> Data {
        return try loadCertificate(filename: "\(name).pub")
    }
    
    /// Load a public key as NIOSSHPublicKey
    static func loadPublicKey(name: String) throws -> NIOSSHPublicKey {
        let path = "\(certificatesPath)/\(name).pub"
        guard let data = FileManager.default.contents(atPath: path) else {
            throw TestError.fileNotFound(path)
        }
        
        let contents = String(data: data, encoding: .utf8)!.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Use NIOSSHPublicKey's built-in parser
        return try NIOSSHPublicKey(openSSHPublicKey: contents)
    }
    
    enum TestError: Error, LocalizedError {
        case fileNotFound(String)
        case invalidFormat
        case invalidBase64
        
        var errorDescription: String? {
            switch self {
            case .fileNotFound(let path):
                return "Test certificate file not found: \(path)"
            case .invalidFormat:
                return "Invalid certificate file format"
            case .invalidBase64:
                return "Invalid base64 encoding in certificate file"
            }
        }
    }
}