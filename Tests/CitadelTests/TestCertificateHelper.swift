import Foundation
import Crypto
import _CryptoExtras
import NIOSSH
import NIOCore
import CCryptoBoringSSL
@testable import Citadel

/// Helper class to load and parse real SSH certificates generated by ssh-keygen
final class TestCertificateHelper {
    
    /// Use generated certificates in temp directory
    static var certificatesPath: String {
        SSHCertificateGenerator.tempDirectory.path
    }
    
    /// Cache for CA key pair to avoid regenerating
    private static var cachedCAKeyPair: (privateKey: URL, publicKey: URL)?
    
    /// Get or generate CA key pair
    static func getOrGenerateCA() throws -> (privateKey: URL, publicKey: URL) {
        if let cached = cachedCAKeyPair {
            return cached
        }
        
        try SSHCertificateGenerator.ensureSSHKeygenAvailable()
        try SSHCertificateGenerator.setUp()
        
        let caKeyPair = try SSHCertificateGenerator.generateCAKeyPair()
        cachedCAKeyPair = caKeyPair
        return caKeyPair
    }
    
    /// Load a certificate file
    static func loadCertificate(filename: String) throws -> Data {
        let path = "\(certificatesPath)/\(filename)"
        guard let data = FileManager.default.contents(atPath: path) else {
            throw TestError.fileNotFound(path)
        }
        
        // SSH certificates are in OpenSSH format, need to parse the base64
        let contents = String(data: data, encoding: .utf8)!.trimmingCharacters(in: .whitespacesAndNewlines)
        let parts = contents.split(separator: " ")
        
        guard parts.count >= 2 else {
            throw TestError.invalidFormat
        }
        
        // The second part is the base64-encoded certificate
        guard let certData = Data(base64Encoded: String(parts[1])) else {
            throw TestError.invalidBase64
        }
        
        return certData
    }
    
    /// Load a private key file
    static func loadPrivateKey(filename: String) throws -> Data {
        let path = "\(certificatesPath)/\(filename)"
        guard let data = FileManager.default.contents(atPath: path) else {
            throw TestError.fileNotFound(path)
        }
        return data
    }
    
    /// Parse an Ed25519 certificate
    static func parseEd25519Certificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: Curve25519.Signing.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        // Generate certificate dynamically
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.ed25519User()
        let (privateKeyPath, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        
        // Load the generated private key
        let keyData = try Data(contentsOf: privateKeyPath)
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<Curve25519.Signing.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
        
        return (privateKey, cert)
    }
    
    /// Parse a P256 ECDSA certificate
    static func parseP256Certificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: P256.Signing.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        // Generate certificate dynamically
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.p256User()
        let (privateKeyPath, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        
        // Load the generated private key
        let keyData = try Data(contentsOf: privateKeyPath)
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<P256.Signing.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
        
        return (privateKey, cert)
    }
    
    /// Parse a P384 ECDSA certificate
    static func parseP384Certificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: P384.Signing.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        // Generate certificate dynamically
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.p384User()
        let (privateKeyPath, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        
        // Load the generated private key
        let keyData = try Data(contentsOf: privateKeyPath)
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<P384.Signing.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
        
        return (privateKey, cert)
    }
    
    /// Parse a P521 ECDSA certificate
    static func parseP521Certificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: P521.Signing.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        // Generate certificate dynamically
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.p521User()
        let (privateKeyPath, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        
        // Load the generated private key
        let keyData = try Data(contentsOf: privateKeyPath)
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<P521.Signing.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
        
        return (privateKey, cert)
    }
    
    /// Parse an RSA certificate
    static func parseRSACertificate(certificateFile: String, privateKeyFile: String) throws -> (privateKey: Insecure.RSA.PrivateKey, certificate: NIOSSHCertifiedPublicKey) {
        // Generate certificate dynamically
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.rsaUser()
        let (privateKeyPath, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        
        // Load the generated private key
        let keyData = try Data(contentsOf: privateKeyPath)
        let keyString = String(data: keyData, encoding: .utf8)!
        let opensshKey = try OpenSSH.PrivateKey<Insecure.RSA.PrivateKey>(string: keyString)
        let privateKey = opensshKey.privateKey
        
        // Parse the certificate using NIOSSHCertificateLoader
        let cert = try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
        
        return (privateKey, cert)
    }
    
    /// Load certificate data directly (without the key type prefix)
    static func loadCertificateData(name: String) throws -> Data {
        return try loadCertificate(filename: "\(name).pub")
    }
    
    /// Load a public key as NIOSSHPublicKey
    static func loadPublicKey(name: String) throws -> NIOSSHPublicKey {
        // For CA keys, use the cached CA public key
        if name == "ca_ed25519" {
            let caKeyPair = try getOrGenerateCA()
            let data = try Data(contentsOf: caKeyPair.publicKey)
            let contents = String(data: data, encoding: .utf8)!.trimmingCharacters(in: .whitespacesAndNewlines)
            return try NIOSSHPublicKey(openSSHPublicKey: contents)
        }
        
        // For other keys, try to load from the temp directory first
        let path = "\(certificatesPath)/\(name).pub"
        guard let data = FileManager.default.contents(atPath: path) else {
            throw TestError.fileNotFound(path)
        }
        
        let contents = String(data: data, encoding: .utf8)!.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Use NIOSSHPublicKey's built-in parser
        return try NIOSSHPublicKey(openSSHPublicKey: contents)
    }
    
    /// Clean up generated certificates
    static func cleanUp() throws {
        try SSHCertificateGenerator.tearDown()
        cachedCAKeyPair = nil
    }
    
    /// Generate host certificate
    static func generateHostCertificate() throws -> NIOSSHCertifiedPublicKey {
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.hostCert()
        let (_, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        return try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
    }
    
    /// Generate certificate with critical options
    static func generateCriticalOptionsCertificate() throws -> NIOSSHCertifiedPublicKey {
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.restrictedUser()
        let (_, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        return try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
    }
    
    /// Generate certificate with limited principals
    static func generateLimitedPrincipalsCertificate() throws -> NIOSSHCertifiedPublicKey {
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.limitedPrincipals()
        let (_, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        return try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
    }
    
    /// Generate certificate with all extensions
    static func generateAllExtensionsCertificate() throws -> NIOSSHCertifiedPublicKey {
        let caKeyPair = try getOrGenerateCA()
        let config = SSHCertificateGenerator.TestCertificateConfig.allExtensions()
        let (_, _, certPath) = try SSHCertificateGenerator.generateTestCertificate(config: config, caKeyPair: caKeyPair)
        return try NIOSSHCertificateLoader.loadFromOpenSSHFile(at: certPath.path)
    }
    
    enum TestError: Error, LocalizedError {
        case fileNotFound(String)
        case invalidFormat
        case invalidBase64
        
        var errorDescription: String? {
            switch self {
            case .fileNotFound(let path):
                return "Test certificate file not found: \(path)"
            case .invalidFormat:
                return "Invalid certificate file format"
            case .invalidBase64:
                return "Invalid base64 encoding in certificate file"
            }
        }
    }
}